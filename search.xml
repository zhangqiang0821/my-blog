<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[微信授权和jssdk部分接口的笔记]]></title>
      <url>http://139.9.57.253/2018/07/18/wx/</url>
      <content type="html"><![CDATA[<h3 id="微信授权和jssdk部分接口的笔记"><a href="#微信授权和jssdk部分接口的笔记" class="headerlink" title="微信授权和jssdk部分接口的笔记"></a>微信授权和jssdk部分接口的笔记</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li>微信接口测试号 <a href="https://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index" target="_blank" rel="external">申请地址</a></li>
<li>微信开发者工具</li>
</ul>
<h4 id="授权登录"><a href="#授权登录" class="headerlink" title="授权登录"></a>授权登录</h4><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ul>
<li><p>前端引导用户授权（跳转授权链接）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> APPID = <span class="string">'wx763ca0ce2d0b75e3'</span>  <span class="comment">// 公众号的appid</span></div><div class="line"><span class="keyword">var</span> REDIRECT_URI = <span class="string">'http://127.0.0.1:8081/VDS/wechat/auth.html'</span> <span class="comment">// 重定向的页面，请求微信授权页面后，微信服务端重定向的页面，微信会在这个页面的url后面加上code</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> SCOPE = <span class="string">'snsapi_userinfo'</span></div><div class="line"><span class="keyword">var</span> STATE = <span class="string">'ddgr56'</span></div><div class="line"><span class="keyword">var</span> AUTH_URL = <span class="string">'https://open.weixin.qq.com/connect/oauth2/authorize?appid='</span></div><div class="line">+ APPID + <span class="string">'&amp;redirect_uri='</span> + REDIRECT_URI + <span class="string">'?url=$URL'</span> + <span class="string">'&amp;response_type=code&amp;scope='</span> + SCOPE + <span class="string">'&amp;state='</span> + STATE + <span class="string">'#wechat_redirect'</span></div><div class="line"></div><div class="line"><span class="comment">// 授权</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">auth</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="built_in">window</span>.location.href = getAuthUrl(url)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上一步返回一个code，把code传回服务端</p>
</li>
<li>服务端通过code，请求微信服务器，拿到 access_token 和  openid</li>
<li>一般，服务端返回openid给前端，授权成功</li>
</ul>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h5><ul>
<li>公众号配置网页授权域名，此域名必须是客户端配置的回调地址的域名，只需要域名，不能带‘http’<ul>
<li><img src="./1531876963902.png" alt="Alt text"></li>
</ul>
</li>
<li>正式的公众号不能用ip</li>
</ul>
<h4 id="微信jssdk使用前置条件"><a href="#微信jssdk使用前置条件" class="headerlink" title="微信jssdk使用前置条件"></a>微信jssdk使用前置条件</h4><ol>
<li>配置接口安全域名<br><img src="./1531879830281.png" alt="Alt text"><br>此域名是需要使用微信jssdk的页面的域名</li>
<li><p>通过config接口注入权限验证配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">wx.config(&#123;</div><div class="line">    debug: <span class="literal">true</span>, <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></div><div class="line">    appId: <span class="string">''</span>, <span class="comment">// 必填，公众号的唯一标识</span></div><div class="line">    timestamp: , <span class="comment">// 必填，生成签名的时间戳</span></div><div class="line">    nonceStr: <span class="string">''</span>, <span class="comment">// 必填，生成签名的随机串</span></div><div class="line">    signature: <span class="string">''</span>,<span class="comment">// 必填，签名</span></div><div class="line">    jsApiList: [] <span class="comment">// 必填，需要使用的JS接口列表</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>获取signature</p>
</li>
</ol>
<ul>
<li>前端传递3个参数到后端<br>  timestamp 时间戳<br>  nonceStr:  随机字符串<br>  url: 需要调用jssdk接口的页面url<ul>
<li>后端先请求微信服务器获取jsapi_ticket（每次签名时，都需要这个参数，所以，这个参数需要服务端保存起来，过期前不用每次请求）</li>
</ul>
</li>
<li>后端对前端传回的参数进行签名（算法查文档），得到signature，返回给前端</li>
</ul>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a><strong>注意</strong></h4><ul>
<li><p>获取jsapi_ticket，需要一个参数   access_token， 但是这个 access_token和授权登录的 access_token不一样！！！！！ 通过下面的接口获得</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https:<span class="comment">//api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$&#123;appId&#125;&amp;secret=$&#123;secret&#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p>关于nonceStr参数，前端是大写S  后端是小写s ！！！！！</p>
</li>
</ul>
<h4 id="定位-（wx-getLocation）"><a href="#定位-（wx-getLocation）" class="headerlink" title="定位 （wx.getLocation）"></a>定位 （wx.getLocation）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">wx.getLocation(&#123;</div><div class="line">type: <span class="string">'wgs84'</span>, <span class="comment">// 默认为wgs84的gps坐标，如果要返回直接给openLocation用的火星坐标，可传入'gcj02'</span></div><div class="line">success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> latitude = res.latitude; <span class="comment">// 纬度，浮点数，范围为90 ~ -90</span></div><div class="line"><span class="keyword">var</span> longitude = res.longitude; <span class="comment">// 经度，浮点数，范围为180 ~ -180。</span></div><div class="line"><span class="keyword">var</span> speed = res.speed; <span class="comment">// 速度，以米/每秒计</span></div><div class="line"><span class="keyword">var</span> accuracy = res.accuracy; <span class="comment">// 位置精度</span></div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ul>
<li>关于type参数，如果需要使用第三方地图服务反向获取地址，需要正确设置这个值（具体看第三方地图服务需要的坐标类型）</li>
<li>如果要获取地址，可以使用腾讯位置服务的 <a href="http://lbs.qq.com/webservice_v1/guide-gcoder.html" target="_blank" rel="external">逆地址解析</a></li>
<li>上面接口需要使用jsonp请求，并设置  output 为 ‘jsonp’ ！！</li>
</ul>
<h4 id="获取图片"><a href="#获取图片" class="headerlink" title="获取图片"></a>获取图片</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">wx.chooseImage(&#123;</div><div class="line">count: <span class="number">1</span>, <span class="comment">// 默认9</span></div><div class="line">sizeType: [<span class="string">'original'</span>, <span class="string">'compressed'</span>], <span class="comment">// 可以指定是原图还是压缩图，默认二者都有</span></div><div class="line">sourceType: [<span class="string">'album'</span>, <span class="string">'camera'</span>], <span class="comment">// 可以指定来源是相册还是相机，默认二者都有</span></div><div class="line">success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> localIds = res.localIds; <span class="comment">// 返回选定照片的本地ID列表，localId可以作为img标签的src属性显示图片</span></div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="获取图片接口返回的数据转base64"><a href="#获取图片接口返回的数据转base64" class="headerlink" title="获取图片接口返回的数据转base64"></a>获取图片接口返回的数据转base64</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wx.getLocalImgData(&#123;</div><div class="line">localId: &apos;&apos;, // 图片的localID</div><div class="line">success: function (res) &#123;</div><div class="line">var localData = res.localData; // localData是图片的base64数据，可以用img标签显示</div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>在ios上面，这个接口返回的是base64的图片，可以直接显示</li>
<li>ios上面返回的头部是 data:image/jgp   可以替换成  data:image/jpeg 防止出现兼容问题</li>
<li>android上，返回的数据不包含头部，需要手动添加  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- android上，返回的数据可能包含换行，需要去掉换行</div><div class="line">```js</div><div class="line">wx.getLocalImgData(&#123;</div><div class="line">                localId: localIds[i],</div><div class="line">                success: function (res) &#123;</div><div class="line">                    var localData = res.localData;</div><div class="line">                    if (localData.indexOf(&apos;data:image&apos;) != 0) &#123;</div><div class="line">                        localData = &apos;data:image/jpeg;base64,&apos; +  localData</div><div class="line">                    &#125;</div><div class="line">                    localData = localData.replace(/\r|\n/g, &apos;&apos;).replace(&apos;data:image/jgp&apos;, &apos;data:image/jpeg&apos;)</div><div class="line">                    showImage(localData)</div><div class="line">                &#125;</div><div class="line">            &#125;);</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        <categories>
            
            <category> js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信 </tag>
            
            <tag> jssdk </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端编程风格指南]]></title>
      <url>http://139.9.57.253/2017/11/03/codeStyle/</url>
      <content type="html"><![CDATA[<h1 id="前端编程风格指南"><a href="#前端编程风格指南" class="headerlink" title="前端编程风格指南"></a>前端编程风格指南</h1><blockquote>
<p>本指南主要针对前端语法、代码风格、应用组织做了一些约定，每条约定尽量以目前使用较多，符合大多数人习惯为原则，并解释了为什么要这样做。相信在团队开发的项目中，大家遵循同样的约定，有利于代码的整洁、项目的稳定，保证项目的可读性、易维护性和扩展性。</p>
</blockquote>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="通用篇"><a href="#通用篇" class="headerlink" title="通用篇"></a><a href="#tongyong">通用篇</a></h2><h2 id="vue篇"><a href="#vue篇" class="headerlink" title="vue篇"></a><a href="#vue">vue篇</a></h2><h2 id="react篇"><a href="#react篇" class="headerlink" title="react篇"></a><a href="#react">react篇</a></h2><hr>
<h2 id="通用篇-1"><a href="#通用篇-1" class="headerlink" title="通用篇"></a><a name="feature">通用篇</a></h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><blockquote>
<p>命名约定对可维护性和可读性非常重要。本指南为文件名、方法名、变量名推荐了一套命名约定。</p>
</blockquote>
<h4 id="使用驼峰命名法"><a href="#使用驼峰命名法" class="headerlink" title="使用驼峰命名法"></a>使用驼峰命名法</h4><ul>
<li>组件的文件名以大写开头（例如User.vue、User.jsx）</li>
<li>普通js文件以小写字母开头（例如index.js、 app.js）</li>
<li>多个单词用驼峰命名法（例如UserList.vue、HonePage.vue）</li>
<li>变量名、常量名和方法名统一小写开头（例如getUserList()）<h5 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a><em>为什么</em></h5></li>
<li>小写开头的驼峰命名比蛇形命名（例如USER_LIST）容易阅读</li>
<li>将常亮名大写是比较过时的做法，当初是为了便于区分常亮和防止常亮被更改，而现在的ide工具的智能提示加上同const定义常亮已经能避免这些问题</li>
</ul>
<h4 id="使用统一的后缀"><a href="#使用统一的后缀" class="headerlink" title="使用统一的后缀"></a>使用统一的后缀</h4><ul>
<li>为同一种类型的文件定义同样的后缀（例如Model、Router、Api、Utils）</li>
<li>统一类型的文件用相同的后缀（例如userModel、commonModel、userRouter、commonRouter）<h5 id="为什么-1"><a href="#为什么-1" class="headerlink" title="为什么"></a><em>为什么</em></h5></li>
<li>统一的后缀一眼就能明白文件是做什么用的</li>
</ul>
<h3 id="应用结构"><a href="#应用结构" class="headerlink" title="应用结构"></a>应用结构</h3><h4 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h4><ul>
<li>将核心模块剥离</li>
<li>将重复2次及以上的代码剥离</li>
</ul>
<h4 id="识别性"><a href="#识别性" class="headerlink" title="识别性"></a>识别性</h4><ul>
<li>做到看一眼目录名就能识别目录下面的文件是什么作用</li>
<li>文件夹层级不要过深，尽量扁平</li>
<li>配置、自动生成的文件不要和源码混在一起</li>
</ul>
<h3 id="编程约定"><a href="#编程约定" class="headerlink" title="编程约定"></a>编程约定</h3><h4 id="用空行或注释行分割第三方导入和应用导入"><a href="#用空行或注释行分割第三方导入和应用导入" class="headerlink" title="用空行或注释行分割第三方导入和应用导入"></a>用空行或注释行分割第三方导入和应用导入</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="comment">// 本地导入</span></div><div class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./global/router'</span></div><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./global/store'</span></div></pre></td></tr></table></figure>
<h4 id="为什么-2"><a href="#为什么-2" class="headerlink" title="为什么"></a><em>为什么</em></h4><ul>
<li>可以让阅读和定位本地导入更加容易</li>
<li>关注分离，一般情况我们不需要关心第三方的导入<h4 id="使用import-export导入和导出模块"><a href="#使用import-export导入和导出模块" class="headerlink" title="使用import/export导入和导出模块"></a>使用import/export导入和导出模块</h4></li>
<li>不要再使用AMD、CMD的导出导入<h4 id="为什么-3"><a href="#为什么-3" class="headerlink" title="为什么"></a><em>为什么</em></h4></li>
<li>AMD、CMD是ES6模块方案之前的第三方方案</li>
</ul>
<h4 id="不要污染全局作用域"><a href="#不要污染全局作用域" class="headerlink" title="不要污染全局作用域"></a>不要污染全局作用域</h4><ul>
<li>如非必要，不要在window下添加任何的方法和属性</li>
</ul>
<h4 id="选择使用async方法"><a href="#选择使用async方法" class="headerlink" title="选择使用async方法"></a>选择使用async方法</h4><ul>
<li>在使用异步方法时，考虑使用async</li>
<li>不要再用callback</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> testAsync () &#123;</div><div class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="keyword">this</span>.$store.dispatch(<span class="string">'testAsync'</span>)</div><div class="line">  <span class="built_in">console</span>.log(data)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="为什么-4"><a href="#为什么-4" class="headerlink" title="为什么"></a><em>为什么</em></h4><ul>
<li>代码可读性更好</li>
<li>使异步操作更容易理解</li>
</ul>
<h4 id="防止页面刷新丢失数据"><a href="#防止页面刷新丢失数据" class="headerlink" title="防止页面刷新丢失数据"></a>防止页面刷新丢失数据</h4><ul>
<li>不要在前一个页面查询下一个页面需要的数据，前一个页面可以通过路由传递简单的值给下个页面，如id</li>
<li>公用数据在最外层的组件初始化</li>
<li>考虑持久化store</li>
</ul>
<h4 id="组件名预定"><a href="#组件名预定" class="headerlink" title="组件名预定"></a>组件名预定</h4><ul>
<li>基础组件应该全部以一个特定的前缀开头（例如My、Base）</li>
<li>和父组件紧密耦合的子组件应该以父组件名作为前缀命名。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">components/</div><div class="line">|- TodoList.vue</div><div class="line">|- TodoListItem.vue</div><div class="line">|- TodoListItemButton.vue</div></pre></td></tr></table></figure>
<h4 id="为什么-5"><a href="#为什么-5" class="headerlink" title="为什么"></a><em>为什么</em></h4><ul>
<li>一眼就能区分基础组件</li>
<li>编辑器通常会按字母顺序组织文件，子组件以父组件的名字为前缀，这些关联的组件会被排列在一起</li>
</ul>
<h4 id="用ES6的语法"><a href="#用ES6的语法" class="headerlink" title="用ES6的语法"></a>用ES6的语法</h4><ul>
<li>能用ES6的地方不用ES5</li>
<li>用let、const替代var，能用const的地方不用let</li>
<li>用箭头函数</li>
<li>多用对象和数组解构</li>
<li>用模板字符串替代字符串的拼接</li>
</ul>
<hr>
<h2 id="Vue篇"><a href="#Vue篇" class="headerlink" title="Vue篇"></a><a name="vue">Vue篇</a></h2><h4 id="尽可能的细分组件"><a href="#尽可能的细分组件" class="headerlink" title="尽可能的细分组件"></a>尽可能的细分组件</h4><ul>
<li>尽量保证一个组件只做一件事</li>
<li>尽可能的复用组件，不一定完全一样的组件才能复用，有点细节的差异可以通过属性控制差异化的显示<h4 id="为什么-6"><a href="#为什么-6" class="headerlink" title="为什么"></a><em>为什么</em></h4></li>
<li>每个组件只需要关注一件事，代码易读</li>
<li>每个vue文件不会太长，容易维护</li>
<li>复用的组件将大大增加代码的可维护性</li>
</ul>
<h4 id="css模块化"><a href="#css模块化" class="headerlink" title="css模块化"></a>css模块化</h4><ul>
<li>组件的style标签一定要加上scoped</li>
<li>全局的样式在入口文件导入</li>
<li>优先使用全局样式，可以用多个全局的样式组合出想要的样式</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"f-12 c-red m-6 p-10"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="为什么-7"><a href="#为什么-7" class="headerlink" title="为什么"></a><em>为什么</em></h4><ul>
<li>使用局部作用域的样式可以防止样式污染全局样式</li>
<li>使用全局样式可以减少局部样式，从而减小应用的体积</li>
<li>使用全局样式可以在有需要的时候统一调整样式</li>
</ul>
<h4 id="按需使用全局store"><a href="#按需使用全局store" class="headerlink" title="按需使用全局store"></a>按需使用全局store</h4><ul>
<li>store只保存组件间需要共享的数据</li>
<li>父子组件的通信可以使用vue自有的方式来实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个方法请求接口返回的数据只是当前组件使用，</span></div><div class="line"><span class="comment">// 直接通过then返回就好了，不用保存在store</span></div><div class="line"><span class="keyword">async</span> test () &#123;</div><div class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="keyword">this</span>.$store.dispatch(<span class="string">'searchFlight'</span>)</div><div class="line">  <span class="built_in">console</span>.log(data) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="为什么-8"><a href="#为什么-8" class="headerlink" title="为什么"></a><em>为什么</em></h4><ul>
<li>减小store的体积，如果需要持久化store，这将很有用</li>
<li>太多的数据会让store变得难以维护和阅读</li>
</ul>
<h4 id="善用计算属性"><a href="#善用计算属性" class="headerlink" title="善用计算属性"></a>善用计算属性</h4><ul>
<li>需要通过一些状态计算获得新状态的情况（如排序、过滤、转换等），选择使用计算属性<h4 id="为什么-9"><a href="#为什么-9" class="headerlink" title="为什么"></a><em>为什么</em></h4></li>
<li>计算属性在依赖的属性值不改变的情况下，不会重复计算，性能比filter、watch要好</li>
</ul>
<h4 id="不用使用refs、parent、children"><a href="#不用使用refs、parent、children" class="headerlink" title="不用使用refs、parent、children"></a>不用使用refs、parent、children</h4><ul>
<li>不是万不得已，不要使用refs、parent、children</li>
<li>用vuex共享组件状态</li>
<li>用emit、on处理事件</li>
<li>用中央总线的方式处理跨组件的事件<h4 id="为什么-10"><a href="#为什么-10" class="headerlink" title="为什么"></a><em>为什么</em></h4></li>
<li>会破坏单向数据流的概念</li>
<li>会加强让组件的耦合，不利于扩展和维护<br>会让代码变得难以阅读</li>
</ul>
<h4 id="推荐的vue文件结构"><a href="#推荐的vue文件结构" class="headerlink" title="推荐的vue文件结构"></a>推荐的vue文件结构</h4><ul>
<li>总体按照模板、js、样式的顺序</li>
<li>js文件中，组件、属性/状态、生命周期、方法的顺序</li>
<li>生命周期方法的顺序依照执行顺序排序</li>
<li>用webstorm的可以将下面的代码存为模板，每次新建一个vue文件，自动生成下面的代码，删掉用不到的部分就可以了</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></div><div class="line"><span class="undefined">    components: &#123;&#125;,</span></div><div class="line"><span class="undefined">    props: &#123;&#125;,</span></div><div class="line"><span class="undefined">    data () &#123;</span></div><div class="line"><span class="javascript">      <span class="keyword">return</span> &#123;&#125;</span></div><div class="line"><span class="undefined">    &#125;,</span></div><div class="line"><span class="undefined">    computed: &#123;</span></div><div class="line"><span class="undefined">      ...mapState([])</span></div><div class="line"><span class="undefined">    &#125;,</span></div><div class="line"><span class="undefined">    beforeCreate () &#123;&#125;,</span></div><div class="line"><span class="undefined">    created () &#123;&#125;,</span></div><div class="line"><span class="undefined">    beforeMount () &#123;&#125;,</span></div><div class="line"><span class="undefined">    mounted () &#123;&#125;,</span></div><div class="line"><span class="undefined">    beforeUpdate () &#123;&#125;,</span></div><div class="line"><span class="undefined">    updated () &#123;&#125;,</span></div><div class="line"><span class="undefined">    beforeDestroy () &#123;&#125;,</span></div><div class="line"><span class="undefined">    destroyed () &#123;&#125;,</span></div><div class="line"><span class="undefined">    methods: &#123;&#125;,</span></div><div class="line"><span class="undefined">    filters: &#123;&#125;</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="为什么-11"><a href="#为什么-11" class="headerlink" title="为什么"></a><em>为什么</em></h4><ul>
<li>使用统一的文件结构有利于提高代码可阅读性</li>
</ul>
<hr>
<h2 id="React篇"><a href="#React篇" class="headerlink" title="React篇"></a><a name="react">React篇</a></h2><h4 id="尽可能的细分组件-1"><a href="#尽可能的细分组件-1" class="headerlink" title="尽可能的细分组件"></a>尽可能的细分组件</h4><ul>
<li>尽量保证一个组件只做一件事</li>
<li>尽可能的复用组件，不一定完全一样的组件才能复用，有点细节的差异可以通过属性控制差异化的显示</li>
<li>不要将每个组件都写成容器组件，一般情况下当前路由最外层的组件为容器组件，负责从store获取状态，子组件为展示组件<h4 id="为什么-12"><a href="#为什么-12" class="headerlink" title="为什么"></a><em>为什么</em></h4></li>
<li>每个组件只需要关注一件事，代码易读</li>
<li>每个jsx文件不会太长，容易维护</li>
<li>复用的组件将大大增加代码的可维护性</li>
<li>一个路由下的组件属性和来源一致，代码已读和容易理解</li>
</ul>
<h4 id="css模块化-1"><a href="#css模块化-1" class="headerlink" title="css模块化"></a>css模块化</h4><ul>
<li>可以使用CSS Modules</li>
<li>用less sass等预编译器，给组件最外层容器设置唯一的className，当前组件的所有样式包含在这个样式下面</li>
<li>全局的样式在入口文件导入</li>
<li>优先使用全局样式，可以用多个全局的样式组合出想要的样式</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> &lt;div className=<span class="string">"user-list"</span>&gt;</div><div class="line">   &lt;div className=<span class="string">"header"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">   &lt;div className=<span class="string">"list"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"> &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">.user-list&#123;</span></div><div class="line"><span class="regexp">  font-size: 14px;</span></div><div class="line"><span class="regexp">  </span></div><div class="line"><span class="regexp">  .list&#123;</span></div><div class="line"><span class="regexp">    padding: 10px;</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure>
<h4 id="为什么-13"><a href="#为什么-13" class="headerlink" title="为什么"></a><em>为什么</em></h4><ul>
<li>使用局部作用域的样式可以防止样式污染全局样式</li>
<li>使用全局样式可以减少局部样式，从而减小应用的体积</li>
<li>使用全局样式可以在有需要的时候统一调整样式</li>
</ul>
<h4 id="按需使用全局store-1"><a href="#按需使用全局store-1" class="headerlink" title="按需使用全局store"></a>按需使用全局store</h4><ul>
<li>store只保存组件间需要共享的数据</li>
<li>展示组件的属性通过父组件传递</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个方法请求接口返回的数据只是当前组件使用，</span></div><div class="line"><span class="comment">// 直接通过then返回就好了，不用保存在store</span></div><div class="line">      <span class="keyword">async</span> test () &#123;</div><div class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="keyword">this</span>.props.actions.getTodoList()</div><div class="line">        <span class="built_in">console</span>.log(data) </div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<h4 id="为什么-14"><a href="#为什么-14" class="headerlink" title="为什么"></a><em>为什么</em></h4><ul>
<li>减小store的体积，如果需要持久化store，这将很有用</li>
<li>太多的数据会让store变得难以维护和阅读</li>
<li>让组件的数据来源变得单一，使组件的状态容易理解</li>
</ul>
<h4 id="使用扁平化的属性"><a href="#使用扁平化的属性" class="headerlink" title="使用扁平化的属性"></a>使用扁平化的属性</h4><h4 id="列表的key"><a href="#列表的key" class="headerlink" title="列表的key"></a>列表的key</h4><h4 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h4><h4 id="用装饰器代替mixins"><a href="#用装饰器代替mixins" class="headerlink" title="用装饰器代替mixins"></a>用装饰器代替mixins</h4><h4 id="不要使用refs"><a href="#不要使用refs" class="headerlink" title="不要使用refs"></a>不要使用refs</h4><h4 id="推荐的jsx文件结构"><a href="#推荐的jsx文件结构" class="headerlink" title="推荐的jsx文件结构"></a>推荐的jsx文件结构</h4>]]></content>
      
        <categories>
            
            <category> js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 风格 </tag>
            
            <tag> 样式 </tag>
            
            <tag> 约定 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js继承]]></title>
      <url>http://139.9.57.253/2017/02/09/jsExtends/</url>
      <content type="html"><![CDATA[<p>收藏几种js继承的实现方式</p>
<h3 id="定义父类"><a href="#定义父类" class="headerlink" title="定义父类"></a>定义父类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义一个动物类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="comment">// 属性</span></div><div class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Animal'</span>;</div><div class="line">  <span class="comment">// 实例方法</span></div><div class="line">  <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉！'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 原型方法</span></div><div class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃：'</span> + food);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>1.原型链继承</strong></p>
<p>核心： 将父类的实例作为子类的原型<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123; </div><div class="line">&#125;</div><div class="line">Cat.prototype = <span class="keyword">new</span> Animal();</div><div class="line">Cat.prototype.name = <span class="string">'cat'</span>;</div><div class="line"></div><div class="line"><span class="comment">//　Test Code</span></div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</div><div class="line"><span class="built_in">console</span>.log(cat.name);</div><div class="line"><span class="built_in">console</span>.log(cat.eat(<span class="string">'fish'</span>));</div><div class="line"><span class="built_in">console</span>.log(cat.sleep());</div><div class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">//true </span></div><div class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>特点：</p>
<ul>
<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li>
<li>父类新增原型方法/原型属性，子类都能访问到</li>
<li>简单，易于实现</li>
</ul>
<p>缺点：</p>
<ul>
<li>要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中</li>
<li>无法实现多继承</li>
<li>来自原型对象的引用属性是所有实例共享的（详细请看附录代码： 示例1）</li>
<li>创建子类实例时，无法向父类构造函数传参</li>
</ul>
<p>推荐指数：★★（3、4两大致命缺陷）</p>
<p><strong>2.构造继承</strong></p>
<p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  Animal.call(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Test Code</span></div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</div><div class="line"><span class="built_in">console</span>.log(cat.name);</div><div class="line"><span class="built_in">console</span>.log(cat.sleep());</div><div class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>特点：</p>
<ul>
<li>解决了1中，子类实例共享父类引用属性的问题</li>
<li>创建子类实例时，可以向父类传递参数</li>
<li>可以实现多继承（call多个父类对象）</li>
</ul>
<p>缺点：</p>
<ul>
<li>实例并不是父类的实例，只是子类的实例</li>
<li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>
</ul>
<p>推荐指数：★★（缺点3）</p>
<p><strong>3.实例继承</strong></p>
<p>核心：为父类实例添加新特性，作为子类实例返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> instance = <span class="keyword">new</span> Animal();</div><div class="line">  instance.name = name || <span class="string">'Tom'</span>;</div><div class="line">  <span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Test Code</span></div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</div><div class="line"><span class="built_in">console</span>.log(cat.name);</div><div class="line"><span class="built_in">console</span>.log(cat.sleep());</div><div class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果</li>
</ul>
<p>缺点：</p>
<ul>
<li>实例是父类的实例，不是子类的实例</li>
<li>不支持多继承</li>
</ul>
<p>推荐指数：★★</p>
<p><strong>4.拷贝继承</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> animal)&#123;</div><div class="line">    Cat.prototype[p] = animal[p];</div><div class="line">  &#125;</div><div class="line">  Cat.prototype.name = name || <span class="string">'Tom'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Test Code</span></div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</div><div class="line"><span class="built_in">console</span>.log(cat.name);</div><div class="line"><span class="built_in">console</span>.log(cat.sleep());</div><div class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>特点：</p>
<ul>
<li>支持多继承</li>
</ul>
<p>缺点：</p>
<ul>
<li>效率较低，内存占用高（因为要拷贝父类的属性）</li>
<li>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</li>
</ul>
<p>推荐指数：★（缺点1）</p>
<p><strong>5.组合继承</strong></p>
<p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  Animal.call(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</div><div class="line">&#125;</div><div class="line">Cat.prototype = <span class="keyword">new</span> Animal();</div><div class="line"></div><div class="line"><span class="comment">// Test Code</span></div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</div><div class="line"><span class="built_in">console</span>.log(cat.name);</div><div class="line"><span class="built_in">console</span>.log(cat.sleep());</div><div class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</li>
<li>既是子类的实例，也是父类的实例</li>
<li>不存在引用属性共享问题</li>
<li>可传参</li>
<li>函数可复用</li>
</ul>
<p>缺点：</p>
<ul>
<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>
</ul>
<p>推荐指数：★★★★（仅仅多消耗了一点内存）</p>
<p><strong>6.寄生组合继承</strong></p>
<p>核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  Animal.call(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</div><div class="line">&#125;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// 创建一个没有实例方法的类</span></div><div class="line">  <span class="keyword">var</span> Super = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">  Super.prototype = Animal.prototype;</div><div class="line">  <span class="comment">//将实例作为子类的原型</span></div><div class="line">  Cat.prototype = <span class="keyword">new</span> Super();</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">// Test Code</span></div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</div><div class="line"><span class="built_in">console</span>.log(cat.name);</div><div class="line"><span class="built_in">console</span>.log(cat.sleep());</div><div class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>堪称完美<br>缺点：</li>
<li>实现较为复杂</li>
</ul>
<p>推荐指数：★★★★（实现复杂，扣掉一颗星）</p>
]]></content>
      
        <categories>
            
            <category> js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js继承 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack笔记]]></title>
      <url>http://139.9.57.253/2017/02/05/webpack/</url>
      <content type="html"><![CDATA[<h3 id="设置favicon"><a href="#设置favicon" class="headerlink" title="设置favicon"></a>设置favicon</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">...</div><div class="line">favicon: <span class="string">'src/assets/img/favicon.ico'</span>,</div><div class="line">...</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> node.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[babel6]]></title>
      <url>http://139.9.57.253/2017/01/21/babel6/</url>
      <content type="html"><![CDATA[<p>在node.js中使用babel6的方法.</p>
<ol>
<li><p>安装babel6 </p>
<blockquote>
<p>npm install babel-core –save</p>
</blockquote>
</li>
<li><p>安装插件</p>
<blockquote>
<p>npm install babel-preset-es2015</p>
</blockquote>
</li>
<li><p>配置bedel6</p>
<p> 方法1 . 新建 .babelrc 文件</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="string">"presets"</span>: [<span class="string">"es2015"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 方法2  在pageage.json里面配置</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"babel"</span>: &#123;</div><div class="line">     <span class="string">"presets"</span>: [<span class="string">"es2015"</span>]</div><div class="line"> 	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>新建 index.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'babel-core/register'</span>)</div><div class="line"><span class="built_in">require</span>(<span class="string">'./app.js'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>运行</p>
<blockquote>
<p>node index.js</p>
</blockquote>
</li>
</ol>
<h3 id="koa2-async-直接使用-runkoa"><a href="#koa2-async-直接使用-runkoa" class="headerlink" title="koa2+async 直接使用 runkoa"></a>koa2+async 直接使用 runkoa</h3><blockquote>
<p>npm i -g runkoa<br>runkoa app.js</p>
</blockquote>
<h3 id="koa生成器-一键生成koa和koa2项目"><a href="#koa生成器-一键生成koa和koa2项目" class="headerlink" title="koa生成器,一键生成koa和koa2项目"></a>koa生成器,一键生成koa和koa2项目</h3><p><a href="https://github.com/17koa/koa-generator" target="_blank" rel="external">koa-generator</a></p>
]]></content>
      
        <categories>
            
            <category> node.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> babel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用axios读取远程图片保存到本地]]></title>
      <url>http://139.9.57.253/2017/01/19/saveimg/</url>
      <content type="html"><![CDATA[<p>使用axios读取远程图片保存到本地</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"> axios.get(<span class="string">'http://139.9.57.253/img/random/2.png'</span>, &#123;</div><div class="line">  responseType: <span class="string">'arraybuffer'</span></div><div class="line"> &#125;)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(response.status);</div><div class="line">      <span class="built_in">console</span>.log(response.headers);</div><div class="line">  	fs.writeFile(<span class="string">'out.png'</span>, response.data, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    	<span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</div><div class="line">    	<span class="built_in">console</span>.log(<span class="string">'保存成功'</span>);</div><div class="line"> 	&#125;);</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> node.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图片 </tag>
            
            <tag> axios </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis笔记]]></title>
      <url>http://139.9.57.253/2017/01/13/redis/</url>
      <content type="html"><![CDATA[<p>redis常用操作</p>
<h3 id="windows下载"><a href="#windows下载" class="headerlink" title="windows下载"></a>windows下载</h3><p><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="external">下载地址</a></p>
<h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><blockquote>
<p>redis-server redis.windows.conf</p>
</blockquote>
<h3 id="设置Redis服务"><a href="#设置Redis服务" class="headerlink" title="设置Redis服务"></a>设置Redis服务</h3><blockquote>
<p>redis-server –service-install redis.windows-service.conf –loglevel verbose</p>
</blockquote>
<p>输入命令之后没有报错，表示成功了，刷新服务，会看到多了一个redis服务</p>
<h3 id="常用的redis服务命令。"><a href="#常用的redis服务命令。" class="headerlink" title="常用的redis服务命令。"></a>常用的redis服务命令。</h3><blockquote>
<p>卸载服务：redis-server –service-uninstall</p>
<p>开启服务：redis-server –service-start</p>
<p>停止服务：redis-server –service-stop</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> nosql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[npm快速发布自己的模块]]></title>
      <url>http://139.9.57.253/2017/01/09/npmPublish/</url>
      <content type="html"><![CDATA[<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><blockquote>
<p>注意创建模块前，先去 <a href="https://www.npmjs.com/" target="_blank" rel="external">npm 官网</a>确认模块名是否未被占用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init</div></pre></td></tr></table></figure>
<h3 id="添加账号"><a href="#添加账号" class="headerlink" title="添加账号"></a>添加账号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ npm adduser   </div><div class="line">Username: your name</div><div class="line">Password: your password</div><div class="line">Email: yourmail@gmail.com</div></pre></td></tr></table></figure>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm publish</div></pre></td></tr></table></figure>
<h3 id="编辑-npmignore"><a href="#编辑-npmignore" class="headerlink" title="编辑 .npmignore"></a>编辑 .npmignore</h3><blockquote>
<p>如果文件夹中存在 .gitignore， 则 .npmignore 与之相同；<br>如果想忽略一些 .gitignore 中没有包括的东西，那么创建一个空的 .npmignore 可覆盖之.<br>npm 社区版本号规则采用的是 <a href="http://semver.org/" target="_blank" rel="external">semver</a> (语义化版本)</p>
</blockquote>
<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>发布时报错：no_perms Private mode enable, only admin can publish this module</p>
<p>因为 npm 镜像源会有延时，替换为官方源即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm config <span class="built_in">set</span> registry http://registry.npmjs.org</div></pre></td></tr></table></figure>
<p>然后重新 adduser</p>
<h3 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h3><blockquote>
<p>[临时] 通过 config 配置指向国内镜像源<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 配置指向源npm info express</span></div><div class="line">npm config <span class="built_in">set</span> registry http://registry.cnpmjs.org</div></pre></td></tr></table></figure></p>
<p>[临时] 通过 npm 命令指定下载源</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm --registry http://registry.cnpmjs.org info express</div></pre></td></tr></table></figure>
<blockquote>
<p>在配置文件 ~/.npmrc 文件写入源地址</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//打开配置文件</div><div class="line">vim ~/.npmrc</div><div class="line">//写入配置文件</div><div class="line">registry =https://registry.npm.taobao.org</div></pre></td></tr></table></figure>
<h3 id="淘宝-npm-镜像"><a href="#淘宝-npm-镜像" class="headerlink" title="淘宝 npm 镜像"></a>淘宝 npm 镜像</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//cnpm</span></div><div class="line">npm install -g cnpm --registry=https:<span class="comment">//registry.npm.taobao.org </span></div><div class="line"></div><div class="line">npm config set registry https:<span class="comment">//registry.npm.taobao.org --global</span></div><div class="line">npm config set disturl https:<span class="comment">//npm.taobao.org/dist --global</span></div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> node.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> npm发布 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[pm2使用介绍]]></title>
      <url>http://139.9.57.253/2017/01/09/pm2/</url>
      <content type="html"><![CDATA[<h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ul>
<li>内建负载均衡（使用 Node cluster 集群模块）</li>
<li>后台运行</li>
<li>0 秒停机重载，我理解大概意思是维护升级的时候不需要停机.</li>
<li>具有 Ubuntu 和 CentOS 的启动脚本</li>
<li>停止不稳定的进程（避免无限循环）</li>
<li>控制台检测</li>
<li>提供 HTTP API</li>
<li>远程控制和实时的接口 API ( Nodejs 模块，允许和 PM2 进程管理器交互 )</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ npm install pm2 -g     <span class="comment"># 命令行安装 pm2 </span></div><div class="line">$ pm2 start app.js -i 4  <span class="comment"># 后台运行pm2，启动4个app.js </span></div><div class="line">                         <span class="comment"># 也可以把'max' 参数传递给 start</span></div><div class="line">                         <span class="comment"># 正确的进程数目依赖于Cpu的核心数目</span></div><div class="line">$ pm2 start app.js --name my-api <span class="comment"># 命名进程</span></div><div class="line">$ pm2 list               <span class="comment"># 显示所有进程状态</span></div><div class="line">$ pm2 monit              <span class="comment"># 监视所有进程</span></div><div class="line">$ pm2 logs               <span class="comment"># 显示所有进程日志</span></div><div class="line">$ pm2 stop all           <span class="comment"># 停止所有进程</span></div><div class="line">$ pm2 restart all        <span class="comment"># 重启所有进程</span></div><div class="line">$ pm2 reload all         <span class="comment"># 0 秒停机重载进程 (用于 NETWORKED 进程)</span></div><div class="line">$ pm2 stop 0             <span class="comment"># 停止指定的进程</span></div><div class="line">$ pm2 restart 0          <span class="comment"># 重启指定的进程</span></div><div class="line">$ pm2 startup            <span class="comment"># 产生 init 脚本 保持进程活着</span></div><div class="line">$ pm2 web                <span class="comment"># 运行健壮的 computer API endpoint (http://localhost:9615)</span></div><div class="line">$ pm2 delete 0           <span class="comment"># 杀死指定的进程</span></div><div class="line">$ pm2 delete all         <span class="comment"># 杀死全部进程</span></div></pre></td></tr></table></figure>
<h3 id="运行进程的不同方式"><a href="#运行进程的不同方式" class="headerlink" title="运行进程的不同方式"></a>运行进程的不同方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ pm2 start app.js -i max    <span class="comment"># 根据有效CPU数目启动最大进程数目</span></div><div class="line">$ pm2 start app.js -i 3      <span class="comment"># 启动3个进程</span></div><div class="line">$ pm2 start app.js -x        <span class="comment">#用fork模式启动 app.js 而不是使用 cluster</span></div><div class="line">$ pm2 start app.js -x -- -a 23   <span class="comment"># 用fork模式启动 app.js 并且传递参数 (-a 23)</span></div><div class="line">$ pm2 start app.js --name serverone  <span class="comment"># 启动一个进程并把它命名为 serverone</span></div><div class="line">$ pm2 stop serverone       <span class="comment"># 停止 serverone 进程</span></div><div class="line">$ pm2 start app.json        <span class="comment"># 启动进程, 在 app.json里设置选项</span></div><div class="line">$ pm2 start app.js -i max -- -a 23                   <span class="comment">#在--之后给 app.js 传递参数</span></div><div class="line">$ pm2 start app.js -i max -e err.log -o out.log  <span class="comment"># 启动 并 生成一个配置文件</span></div><div class="line"><span class="comment">#你也可以执行用其他语言编写的app  ( fork 模式):</span></div><div class="line">$ pm2 start my-bash-script.sh    -x --interpreter bash</div><div class="line">$ pm2 start my-python-script.py -x --interpreter python</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> node.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pm2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[markdown语法]]></title>
      <url>http://139.9.57.253/2017/01/06/md/</url>
      <content type="html"><![CDATA[<p>既然以后要使用md来写笔记，首先当然要记下常用的md语法。</p>
<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>星号与下划线都可以，单是斜体，双是粗体，符号可跨行，符号可加空格</p>
<blockquote>
<p><strong>加粗</strong><br><strong>加粗</strong><br><em>斜体<br>符号可以换行</em><br><em>斜体</em></p>
</blockquote>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>三个或更多-，必须单独一行，可含空格</p>
<blockquote>
<h2 id="a"><a href="#a" class="headerlink" title="a "></a>a </h2><p>b</p>
</blockquote>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>三个或更多 ===  —  或者#  1-6个</p>
<blockquote>
<h1 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h1><h2 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h2><h1 id="1级标题"><a href="#1级标题" class="headerlink" title="1级标题"></a>1级标题</h1><h2 id="2级标题"><a href="#2级标题" class="headerlink" title="2级标题"></a>2级标题</h2><h3 id="3级标题"><a href="#3级标题" class="headerlink" title="3级标题"></a>3级标题</h3><h4 id="4级标题"><a href="#4级标题" class="headerlink" title="4级标题"></a>4级标题</h4><h5 id="5级标题"><a href="#5级标题" class="headerlink" title="5级标题"></a>5级标题</h5><h6 id="6级标题"><a href="#6级标题" class="headerlink" title="6级标题"></a>6级标题</h6></blockquote>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>-+*</p>
<blockquote>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>无序列表</li>
</ul>
</blockquote>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>数字不能省略但可无序，点号之后的空格不能少</p>
<blockquote>
<ol>
<li>有序列表</li>
<li>有无序列表</li>
<li>有序列表</li>
</ol>
</blockquote>
<h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>-+*可循环使用，但符号之后的空格不能少，符号之前的空格也不能少</p>
<blockquote>
<ul>
<li>嵌套列表</li>
</ul>
<ul>
<li>嵌套列表</li>
<li>嵌套列表<ul>
<li>嵌套列表<ul>
<li>嵌套列表</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>嵌套列表</li>
</ul>
</blockquote>
<h3 id="文字超链接"><a href="#文字超链接" class="headerlink" title="文字超链接"></a>文字超链接</h3><blockquote>
<p><a href="http://zhangqiang0821.github.io" title="cc的博客" target="_blank" rel="external">cc</a></p>
</blockquote>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>![alt] (url “title”) 去掉括号前的空格</p>
<blockquote>
<p><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png" alt="GitHub Mark" title="GitHub Mark"><br><img src="1.png" alt="alt" title="title"></p>
</blockquote>
<h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>直接加尖括号</p>
<blockquote>
<p><a href="http://139.9.57.253">http://139.9.57.253</a></p>
</blockquote>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">$initHighlight</span>(<span class="params">block, cls</span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">if</span> (cls.search(<span class="regexp">/\bno\-highlight\b/</span>) != <span class="number">-1</span>)</div><div class="line">      <span class="keyword">return</span> process(block, <span class="literal">true</span>, <span class="number">0x0F</span>) +</div><div class="line">             <span class="string">` class="<span class="subst">$&#123;cls&#125;</span>"`</span>;</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="comment">/* handle exception */</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> / <span class="number">2</span>; i &lt; classes.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (checkCondition(classes[i]) === <span class="literal">undefined</span>)</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'undefined'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span>  $initHighlight;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 杂项 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> md </tag>
            
            <tag> markdown </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
